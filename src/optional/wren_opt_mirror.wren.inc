// Generated automatically from src/optional/wren_opt_mirror.wren. Do not edit.
static const char* mirrorModuleSource =
"\n"
"class Mirror {\n"
"  static reflect(reflectee) {\n"
"    var type = ObjectMirror.typeOf(reflectee)\n"
"    var mirror = ObjectMirror\n"
"    if (type.type == Class) mirror = ClassMirror\n"
"    if (type == Fiber) mirror = FiberMirror\n"
"\n"
"    return mirror.reflect_(reflectee)\n"
"  }\n"
"}\n"
"\n"
"class ObjectMirror is Mirror {\n"
"  foreign static canInvoke(reflectee, signature)\n"
"  foreign static typeOf(reflectee)\n"
"\n"
"  static reflect_(reflectee) { new_(reflectee) }\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  ==(rhs) { Object.same(reflectee, rhs.reflectee) }\n"
"  !=(rhs) { !(this == rhs) }\n"
"\n"
"  classMirror { _classMirror ||\n"
"      (_classMirror = Mirror.reflect(ObjectMirror.typeOf(_reflectee))) }\n"
"\n"
"  moduleMirror { classMirror.moduleMirror }\n"
"\n"
"  reflectee { _reflectee }\n"
"\n"
"  canInvoke(signature) { ObjectMirror.canInvoke(_reflectee, signature) }\n"
"}\n"
"\n"
"class ClassMirror is ObjectMirror {\n"
"  foreign static hasMethod(reflectee, signature)\n"
"  foreign static methodNames(reflectee)\n"
"  foreign static module_(reflectee)\n"
"\n"
"  static init_() {\n"
"    __cache = {}\n"
"  }\n"
"\n"
"  static reflect_(reflectee) { __cache[reflectee] ||\n"
"      (__cache[reflectee] = ClassMirror.new_(reflectee)) }\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"  }\n"
"\n"
"  moduleMirror { _moduleMirror ||\n"
"      (_moduleMirror = ModuleMirror.reflect_(ClassMirror.module_(reflectee))) }\n"
"\n"
"  methodNames { _methodNames ||\n"
"      (_methodNames = ClassMirror.methodNames(reflectee)) }\n"
"\n"
"  methodMirrors { _methodMirrors }\n"
"\n"
"  hasMethod(signature) { ClassMirror.hasMethod(reflectee, signature) }\n"
"}\n"
"ClassMirror.init_()\n"
"\n"
"class ClosureMirror is Mirror {\n"
"  foreign static boundToClass_(reflectee)\n"
"  foreign static module_(reflectee)\n"
"  foreign static signature_(reflectee)\n"
"\n"
"  static reflect_(reflectee) { new_(reflectee) }\n"
"\n"
"  construct new_(reflectee) {\n"
"    _moduleMirror = ModuleMirror.new_(ClosureMirror.module_(reflectee))\n"
"    _signature = ClosureMirror.signature_(reflectee)\n"
"  }\n"
"\n"
"  reflectee_ { _reflectee }\n"
"\n"
"  ==(rhs) { Object.same(_reflectee, rhs.reflectee_) }\n"
"  !=(rhs) { !(this == rhs) }\n"
"\n"
"  moduleMirror { _moduleMirror }\n"
"\n"
"  signature { _signature }\n"
"}\n"
"\n"
"class FiberMirror is ObjectMirror {\n"
"  foreign static closureAt_(reflectee, stackTraceIndex)\n"
"  foreign static lineAt_(reflectee, stackTraceIndex)\n"
"  foreign static stackFramesCount_(reflectee)\n"
"\n"
"  static reflect_(reflectee) { new_(reflectee) }\n"
"\n"
"  construct new_(reflectee) {\n"
"    super(reflectee)\n"
"  }\n"
"\n"
"  static current { reflect_(Fiber.current) }\n"
"\n"
"  stackTrace() {\n"
"    var reflectee = this.reflectee\n"
"\n"
"    return StackTrace.new_(reflectee, FiberMirror.stackFramesCount_(reflectee))\n"
"  }\n"
"}\n"
"\n"
"class MethodMirror is Mirror {\n"
"  foreign static signature_(signatureIndex)\n"
"\n"
"  construct new_(boundToClassMirror, signatureIndex) {\n"
"    _boundToClassMirror = boundToClassMirror\n"
"    _signatureIndex = signatureIndex\n"
"  }\n"
"\n"
"  boundToClassMirror { _boundToClassMirror }\n"
"\n"
"  moduleMirror { _boundToClassMirror.moduleMirror }\n"
"\n"
"//  arity { MethodMirror.arity_(_method) }\n"
"//  maxSlots { MethodMirror.maxSlots_(_method) }\n"
"//  numUpvalues { MethodMirror.maxSlots_(_numUpvalues) }\n"
"  signature { MethodMirror.signature_(_method) }\n"
"}\n"
"\n"
"class ModuleMirror is Mirror {\n"
"  foreign static current_\n"
"  foreign static fromName_(name)\n"
"  foreign static name_(reflectee)\n"
"\n"
"  static init_() {\n"
"    __cache = {}\n"
"  }\n"
"\n"
"  static reflect_(reflectee) { __cache[reflectee] ||\n"
"      (__cache[reflectee] = ModuleMirror.new_(reflectee)) }\n"
"\n"
"  construct new_(reflectee) {\n"
"    _reflectee = reflectee\n"
"  }\n"
"\n"
"  reflectee_ { _reflectee }\n"
"\n"
"  ==(rhs) { Object.same(_reflectee, rhs.reflectee_) }\n"
"  !=(rhs) { !(this == rhs) }\n"
"\n"
"  static current { reflect_(current_) }\n"
"\n"
"  static fromName(name) {\n"
"    var module = fromName_(name)\n"
"    if (null == module) Fiber.abort(\"Unkown module\")\n"
"\n"
"    return reflect_(module)\n"
"  }\n"
"\n"
"  name { ModuleMirror.name_(_reflectee) }\n"
"}\n"
"ModuleMirror.init_()\n"
"\n"
"class StackTrace is Sequence {\n"
"  construct new_(fiber, stackFramesCount) {\n"
"    _fiber = fiber\n"
"    _stackTrace = []\n"
"\n"
"    if (stackFramesCount == 0) return\n"
"\n"
"    var stackFramesStart = stackFramesCount - (fiber != Fiber.current ? 1 : 2)\n"
"\n"
"    for (stackFramesIndex in stackFramesStart..0) {\n"
"      _stackTrace.add(StackTraceFrame.new_(this, stackFramesIndex,\n"
"          ClosureMirror.new_(FiberMirror.closureAt_(fiber, stackFramesIndex)),\n"
"          FiberMirror.lineAt_(fiber, stackFramesIndex)))\n"
"    }\n"
"  }\n"
"\n"
"  static new(fiber) { new_(fiber, FiberMirror.stackFramesCount_(fiber)) }\n"
"\n"
"  count { _stackTrace.count }\n"
"  iterate(iterator) { _stackTrace.iterate(iterator) }\n"
"  iteratorValue(iterator) { _stackTrace.iteratorValue(iterator) }\n"
"\n"
"  toString { _stackTrace.join(\"\\n\") }\n"
"}\n"
"\n"
"class StackTraceFrame {\n"
"  construct new_(stackTrace, index, closureMirror, line) {\n"
"    _stackTrace = stackTrace\n"
"    _index = index\n"
"\n"
"    _closureMirror = closureMirror\n"
"    _line = line\n"
"  }\n"
"\n"
"  stackTrace { _stackTrace }\n"
"  index { _index }\n"
"\n"
"  closureMirror { _closureMirror }\n"
"  line { _line }\n"
"\n"
"  toString { \"[%(_closureMirror.moduleMirror.name) line %(_line)] in %(_closureMirror.signature)\" }\n"
"}\n";
